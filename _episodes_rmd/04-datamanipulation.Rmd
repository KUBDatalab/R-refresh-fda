---
title: "Manipulation af data"
teaching: 10
exercises: 5
questions:
- "FIX ME"
objectives:
- "FIX ME"
keypoints:
- "FIX ME"

source: Rmd
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("04-")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Datamanipulation

Der skal arbejdes med data. Og data har ikke altid den struktur og form som vi 
godt kunne tænke os. Det kan også være vi gerne vil kigge på bestemte dele af 
datasættet. 

Det kalder vi for datamanipulation. Den sidste del, hvor vi piller bestemte dele
af data ud af det større hele, kalder vi mere specifikt for *subsetting*

Det kan gøres på flere forskellige måder. Vi vil gerne præsentere forskellige
måder. Hvis den ene virker svær, kan vi være heldige at en af de andre måder er 
let. Og den måde der er praktisk i en sammenhæng kan være upraktisk i en anden.


### Indlæs data

Det allerførste vi skal gøre er at indlæse data. I har kigget på noterne om 
organisering af jeres arbejde, så I har selvfølgelig jeres data liggende i mappen
*data* i projektet.

Uanset hvilken funktion vi skal bruge til at indlæse data, skal vi angive hvor
data befinder sig. Det gør vi med en tekststreng:

"data/Results Panel.xlsx"

Her er filen en Excel fil. Så vi skal have fat på biblioteket `readxl`, der har
en funktion der kan læse Excel-filer:


```{r}
library(readxl)
kaffe <- read_excel("../data/Results Panel.xlsx")
```

Hvis det var en csv fil vi arbejdede med vil vi som regel bruge en af 
funktionerne `read.csv`, `read.csv2`, `read_csv` eller `read_csv2`

> ## Hvad er forskellene?
> 
> I Excel har vi data organiseret i rækker og kolonner. Ikke alle har Excel, så
> vi udveksler ofte data i CSV-filer. CSV-filer er tekstfiler. Der er en linie
> for hver række i Excel-filen. Og de enkelte kolonner er adskilt med kommaer.
> 
> Det er et problem for alle de sprog der bruger kommaer i tal. Vi kan ikke skelne
> mellem kommaet i 3,14 og kommaet der adskiller 3,14 fra 2,72. Derfor bruges der 
> ofte et semikolon ";" til at adskille kolonnerne.
> 
> read.csv indlæser kommaseparerede filer der faktisk er bruger kommaer til at adskille
> kolonnerne. read.csv2 indlæser kommaseparerede filer der bruger semikolon i stedet.
>
> read_csv og read_csv2 er funktioner der kommer fra `readr` pakken, der er en
> del af `tidyverse`. De er hurtigere og mere moderne, i den forstand at alt det >der har irriteret brugere af R ved read.csv funktionerne gennem årene er blevet
> forbedret i read_csv.
{: .callout}

### Subsetting

Når vi har fået indlæst data, har vi ofte brug for at 
subsette data. Det vil sige, trække en eller flere kolonner ud af datasættet.
Eller kun kigge på et udvalg af rækkerne, der opfylder et eller andet kriterium.
Det tekniske begreb er "subsetting", og det er et
nyttigt ord at kende når der skal googles efter 
løsninger.

#### $-notationen

Ønsker vi at trække en enkelt kolonne ud af en dataframe,
kan vi bruge $-notationen:
```{r eval = F}
kaffe$Sour
```
```{r echo = F}
head(kaffe$Sour)
```
Det giver os værdierne i kolonnen *Sour* i datasættet *kaffe*

Vil vi trække mere end en kolonne ud af datasættet kan vi bruge en notation 
med kantede paranteser:

```{r eval=F}
kaffe[,c(2,4,6)]
```

```{r echo =F }
head(kaffe[,c(2,4,6)])
```
Her beder vi om at få kolonne nr. 2, 4 og 6.


Hvorfor står der ikke noget foran kommaet i de kantede paranteser? 

De kantede paranteser kan bruges til at specificere ikke kun kolonner, men også 
rækker. Det vi skriver foran kommaet fortæller hvilke rækker vi vil have. Det vi 
skriver efter kommaet hvilke kolonner vi vil have. Skriver vi slet ikke noget,
får vi alt, her alle rækkerne (bortset fra at vi begrænser det til de 6 første 
rækker, fordi det fylder for meget at skrive det hele ud).



logiske vektorer i denne kontekst.

## Subsetting

Endelig er der en specifik funktion `subset()` der
kan benyttes

```{r}
subset(airquality, Temp > 80, select = c(Ozone, Temp))
subset(airquality, Day == 1, select = -Temp)
subset(airquality, select = Ozone:Wind)
```

### Renaming kolonner

Undertiden har vi behov for at omdøbe kolonner.

Navnene på kolonner i en dataframe, kan vi trække ud
ved brug af funktionen `names`

Og så assigne nye navne.

"Best practice" omkring kolonnenavne er at undgå 
mellemrum, kolonnenavne der starter med tal og i det 
hele taget at undgå specialtegn.

Når man indlæser data oplever man ofte at kolonnenavnene
ikke overholder disse regler. 

backticks er løsningen.
  
### Tidy
I skal vide hvordan ovenstående fungerer. For det 
er måden det gøres i undervisningsmaterialet. 
Men der er andre måder, som I måske bedre kan lide.

Ved at indlæse biblioteket `tidyverse` får vi adgang 
til en række funktioner, der alle har det til fælles,
at de som deres første argument skal bruge en dataframe.
Og som returnerer en dataframe. 

Det betyder at vi kan bruge en særlig operator, %>%,
der tager hvad der står på venstre side af den, og sender
videre til det der står på højre side.

Har vi derfor en dataframe, eller en funktion der 
returnerer en dataframe, på venstre side af %>% pipen,
vil den dataframe blive sendt videre til en funktion 
på højre side, og indsat som det første argument.

Det, i kombination med funktioner fra tidyverse, kan
hjælpe til at gøre manipulation af dataframes mere 
overskuelig.

Udvælgelse af bestemte kolonner:
```{r}
library(tidyverse)
kaffe %>% 
  select(Assessor, Bitter, Sour)
```

Her sender vi datasættet kaffe til funktionen `select`, og angiver at vi godt
vil vælge kolonnerne "Assessor", "Bitter" og "Sour"

Udvælgelse af bestemte rækker:
```{r}
kaffe %>% 
  select(Assessor, Bitter, Sour) %>% 
  filter(Assessor == 1)
```

Efter vi har sendt datasættet "kaffe" til select funktionen, og udvalgt
de tre kolonner vi er interesserede i, sender vi dem videre til filter funktionen,
hvor vi filtrerer rækkerne, så vi kun får de rækker hvor Assessor er lig med 1.

Vi kunne også have brugt udtryk som "Assessor < 4" for at få alle de smagsdommere
der har nummer lavere end 4.

Endelig kan vi have brug for at foretage beregninger på data i kolonnerne, og 
lave en ny kolonne, baseret på de eksisterende kolonner:


```{r}
kaffe %>% 
  select(Assessor, Bitter, Sour) %>% 
  filter(Assessor == 1) %>% 
  mutate(ny_kolonne = Bitter*Sour)
```
Hvorfor vi nogensinde skulle have lyst til at gange de to sæt tal sammen ved vi
ikke. Det vigtige er at vi kan lave en ny kolonne, baseret på en eller flere af
de eksisterende kolonner.



MUTATE? ENE NÆRLÆSER UNDERVISNINGSMATERIALET.

Bemærk at funktionerne ikke egentlig ændrer data.
Vi ser et output, men det data vi starter med at 
sende ind i pipen bliver ikke ændret. Derfor, gem 
resultatet i et nyt objekt hvis du har brug for det. 

Det kunne se sådan ud:
```{r eval = F}
nyt_kaffe_data <- kaffe %>% 
  select(Assessor, Bitter, Sour) %>% 
  filter(Assessor == 1) %>% 
  mutate(ny_kolonne = Bitter*Sour)
```



### Gemme data!

Når du er færdig med at manipulere data, kan det 
være du har brug for at gemme data.  Oftest vil det være tabel-data du ønsker at 
gemme, og der er csv-filer vejen frem.

CSV-filer kunne indlæses på flere forskellige måder. Vi kan også gemme dem på
flere forskellige måder: `write.csv`, `write.csv2`, `write_csv` eller `write_csv2`:

```{r eval = F}
write.csv2(nyt_kaffe_data, "KORREKTMAPPE/nyt_kaffe_data.csv")
```

Her gemmer vi en semikolon-separeret csv-fil i KORREKTMAPPE.

#### Gemme mærkelige datatyper
Nogle datatyper, eksempelvis det der kommer ud af at 
lave en statistisk model, kan ikke gemmes som 
csv-filer. Men frygt ej, R har måder at gemme den 
slags på:

```{r eval = F}
saveRDS(sær_data, file = "KORREKTMAPPE/sær_data.rda")
```

Disse gemte objekter kan så indlæses igen:

```{r eval = F}
readRDS(file = "KORREKTMAPPE/sær_data.rda")
```



{% include links.md %}