---
title: "Opdatering"
teaching: 10
exercises: 5
questions:
- "FIX ME"
objectives:
- "FIX ME"
keypoints:
- "FIX ME"

source: Rmd
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("40-")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Arbejdstitel pakker.

Pakker hører til i starten.
Rækkefølgen er installer pakker, og dernæst indlæs pakker.
masking og conflicts af funktioner. Så tænk også over rækkefølgen af
library! og dermed pakkenavn::funktion
installer devtools!
Brug devtools til at opdatere (praktisk øvelse)
github vs. cran vs. lokale funktioner/source
installer ggbiplot
  det er en funktion 
    og kan derfor "indlæses" med source funktionen. (og den ligger fint i en scripts mappe!)


## ggbiplot

Vi kommer ikke her til at bruge tid på biplots. Det er en del af
kurset fødevaredataanalyse, og Morten forklarer bedre end vi 
nogensinde kommer til hvad PCA er og hvad det kan bruges til.

En pakke I kommer til at bruge til at plotte resultaterne af 
en Principal Component Analyse, er `ggbiplot`.

Den ligger ikke på CRAN, men på GitHub, og skal derfor installeres
på en særlig måde: 

```{r ggbiplot-fra-github, eval = F}
library(devtools)
install_github("vqv/ggbiplot")
```

Pakken devtools indeholder en funktion; `install_github()`. Den skal
have navnet på det "repository" på GitHub der indeholder pakken.

MARKERING: I undervisningsmaterialet angives en anden måde at 
installere pakken på:
install_github("ggbiplot", "vqv")
Det udløser en kedelig fejlbesked:
Error in parse_repo_spec(repo) : 
Invalid git repo specification: 'ggbiplot'

Hvorfor? Fordi install_github funktionen er blevet opdateret, og 
nu skal have adressen specificeret på en anden måde.

For de fleste brugere af github er det en gratis tjeneste. Det 
fører til begrænsninger. En af dem er hvor mange der kan 
downloade pakker indenfor et bestemt tidsrum. Og den begrænsning
støder nogle af jer på i dette kursus.

Og hvad gør man så når man skal bruge ggbiplot, men ikke kan få
lov at installere pakken?

Lige ggbiplot er en *meget* simpel pakke. Den indeholder en enkelt
funktion. Og den kan vi få adgang til på andre måder.

I jeres projekt laver I mappen `scripts`. I den mappe opretter
I en R-script fil med navnet `ggbiplot.R`. Den åbner I, og kopierer
nedenstående R-kode ind i den:
```{r ggbiplot-kode, eval = F}
ggbiplot <- function(pcobj, choices = 1:2, scale = 1, pc.biplot = TRUE, 
                      obs.scale = 1 - scale, var.scale = scale, 
                      groups = NULL, ellipse = FALSE, ellipse.prob = 0.68, 
                      labels = NULL, labels.size = 3, alpha = 1, 
                      var.axes = TRUE, 
                      circle = FALSE, circle.prob = 0.69, 
                      varname.size = 3, varname.adjust = 1.5, 
                      varname.abbrev = FALSE, ...)
{
  library(ggplot2)
  library(plyr)
  library(scales)
  library(grid)

  stopifnot(length(choices) == 2)

  # Recover the SVD
 if(inherits(pcobj, 'prcomp')){
    nobs.factor <- sqrt(nrow(pcobj$x) - 1)
    d <- pcobj$sdev
    u <- sweep(pcobj$x, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- pcobj$rotation
  } else if(inherits(pcobj, 'princomp')) {
    nobs.factor <- sqrt(pcobj$n.obs)
    d <- pcobj$sdev
    u <- sweep(pcobj$scores, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- pcobj$loadings
  } else if(inherits(pcobj, 'PCA')) {
    nobs.factor <- sqrt(nrow(pcobj$call$X))
    d <- unlist(sqrt(pcobj$eig)[1])
    u <- sweep(pcobj$ind$coord, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- sweep(pcobj$var$coord,2,sqrt(pcobj$eig[1:ncol(pcobj$var$coord),1]),FUN="/")
  } else if(inherits(pcobj, "lda")) {
      nobs.factor <- sqrt(pcobj$N)
      d <- pcobj$svd
      u <- predict(pcobj)$x/nobs.factor
      v <- pcobj$scaling
      d.total <- sum(d^2)
  } else {
    stop('Expected a object of class prcomp, princomp, PCA, or lda')
  }

  # Scores
  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[,choices], 2, d[choices]^obs.scale, FUN='*'))

  # Directions
  v <- sweep(v, 2, d^var.scale, FUN='*')
  df.v <- as.data.frame(v[, choices])

  names(df.u) <- c('xvar', 'yvar')
  names(df.v) <- names(df.u)

  if(pc.biplot) {
    df.u <- df.u * nobs.factor
  }

  # Scale the radius of the correlation circle so that it corresponds to 
  # a data ellipse for the standardized PC scores
  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)

  # Scale directions
  v.scale <- rowSums(v^2)
  df.v <- r * df.v / sqrt(max(v.scale))

  # Change the labels for the axes
  if(obs.scale == 0) {
    u.axis.labs <- paste('standardized PC', choices, sep='')
  } else {
    u.axis.labs <- paste('PC', choices, sep='')
  }

  # Append the proportion of explained variance to the axis labels
  u.axis.labs <- paste(u.axis.labs, 
                       sprintf('(%0.1f%% explained var.)', 
                               100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))

  # Score Labels
  if(!is.null(labels)) {
    df.u$labels <- labels
  }

  # Grouping variable
  if(!is.null(groups)) {
    df.u$groups <- groups
  }

  # Variable Names
  if(varname.abbrev) {
    df.v$varname <- abbreviate(rownames(v))
  } else {
    df.v$varname <- rownames(v)
  }

  # Variables for text label placement
  df.v$angle <- with(df.v, (180/pi) * atan(yvar / xvar))
  df.v$hjust = with(df.v, (1 - varname.adjust * sign(xvar)) / 2)

  # Base plot
  g <- ggplot(data = df.u, aes(x = xvar, y = yvar)) + 
          xlab(u.axis.labs[1]) + ylab(u.axis.labs[2]) + coord_equal()

  if(var.axes) {
    # Draw circle
    if(circle) 
    {
      theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
      circle <- data.frame(xvar = r * cos(theta), yvar = r * sin(theta))
      g <- g + geom_path(data = circle, color = muted('white'), 
                         size = 1/2, alpha = 1/3)
    }

    # Draw directions
    g <- g +
      geom_segment(data = df.v,
                   aes(x = 0, y = 0, xend = xvar, yend = yvar),
                   arrow = arrow(length = unit(1/2, 'picas')), 
                   color = muted('red'))
  }

  # Draw either labels or points
  if(!is.null(df.u$labels)) {
    if(!is.null(df.u$groups)) {
      g <- g + geom_text(aes(label = labels, color = groups), 
                         size = labels.size)
    } else {
      g <- g + geom_text(aes(label = labels), size = labels.size)      
    }
  } else {
    if(!is.null(df.u$groups)) {
      g <- g + geom_point(aes(color = groups), alpha = alpha)
    } else {
      g <- g + geom_point(alpha = alpha)      
    }
  }

  # Overlay a concentration ellipse if there are groups
  if(!is.null(df.u$groups) && ellipse) {
    theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
    circle <- cbind(cos(theta), sin(theta))

    ell <- ddply(df.u, 'groups', function(x) {
      if(nrow(x) <= 2) {
        return(NULL)
      }
      sigma <- var(cbind(x$xvar, x$yvar))
      mu <- c(mean(x$xvar), mean(x$yvar))
      ed <- sqrt(qchisq(ellipse.prob, df = 2))
      data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = '+'), 
                 groups = x$groups[1])
    })
    names(ell)[1:2] <- c('xvar', 'yvar')
    g <- g + geom_path(data = ell, aes(color = groups, group = groups))
  }

  # Label the variable axes
  if(var.axes) {
    g <- g + 
    geom_text(data = df.v, 
              aes(label = varname, x = xvar, y = yvar, 
                  angle = angle, hjust = hjust), 
              color = 'darkred', size = varname.size)
  }
  # Change the name of the legend for groups
  # if(!is.null(groups)) {
  #   g <- g + scale_color_brewer(name = deparse(substitute(groups)), 
  #                               palette = 'Dark2')
  # }

  # TODO: Add a second set of axes

  return(g)
}
```

Gem derefter filen. Nu har I en ggbiplot.R fil liggende i
jeres projekt. Den kan indlæses på en snedig måde, der giver
jer adgang til funktionen også selvom I ikke har kunne installere den.

I starten af jeres script, lige efter I ellers har indlæst
bibliotekek, sætter I en enkelt linie ind:
```{r source-ggbiplot.R, eval = F }
source("scripts/ggbiplot.R")
```

Og så er der fri adgang til at bruge ggbiplot funktionen fuldstændig
som om den var installeret. 

Husk alligevel at få installeret ggbiplot-pakken ved lejlighed.
Metoden herover fungerer fint, men får ikke hjælpe filer og
andet nyttigt med, så det ér en nødløsning.

Det er et stykke tid siden I brugte R sidst. Så nu er der sikkert kommet 
opdateringer.

Det er en god ide at bruge den samme version af R hele vejen gennem dette kursus.
Det er ikke meget avancerede ting I kommer til at lave, så problemet vil næppe
være stort. Men det vil være meget træls at opdatere R dagen før eksamen og finde
ud af at noget er holdt op med at virke.

Så.
Opdater RStudio.

og opdater R.

R opdaterer vi ganske enkelt ved at installere seneste version. Rstudio vælger
automatisk den seneste version af R.

R studio er også blot at downloade og installere den. Så fungerer tingene.

Husk at når I har opdateret RStudio, og særligt når I har opdateret R, så
vil der sandsynligvis være en del af de pakker I allerede har installeret, der 
skal opdateres.

Vi har under alle omstændigheder behov for at have pakken devtools installeret.
Det betyder at vi kan kalde følgende funktion, der tillader os at vælge 
hvilke der skal opdateres.

```{r eval = F}
devtools::update_packages()
y <- rchisq(500, df = 3)
plot(qchisq(ppoints(500), df = 3))

ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
summary(lm.D9)
```



{% include links.md %}