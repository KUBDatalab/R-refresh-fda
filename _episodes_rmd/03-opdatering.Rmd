---
title: "Pakker og opdatering"
teaching: 10
exercises: 5
questions:
- "FIX ME"
objectives:
- "FIX ME"
keypoints:
- "FIX ME"

source: Rmd
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("03-")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Pakker

## Installation og indlæsning
Pakker i R er samlinger af funktioner som kan være nyttige i forskellige sammenhænge. De fleste pakker vi får brug for, er samlet på `CRAN`, "The Comprehensive R Archive Network". Disse pakker, er blevet udsat for et minimum
af kvalitetskontrol. Det er ingen garantier for at de fungerer som vi forventer, men sandsynligheden er ret høj.

Når vi skal bruge en pakke til vores programmering, skal vi gøre to ting.

1. Installere pakken på computeren. 
2. Indlæse pakken i R.

Pakker fra `CRAN` installeres på computeren på denne måde:

```{r eval = F}
install.packages("devtools")
```

Vi angiver navnet på pakken som en tekststreng. install.packages() funktionen søger efter navnet, og finder den noget, installeres pakken på vores computer.

I dette tilfælde er det pakken `devtools` en samling af værktøjer der er nyttige når man udvikler ny funktionalitet i R. Men pakken indeholder andet der kan være nyttigt i dette kursus. Dette ser vi nærmere på senere.

Når pakken så er installeret på computeren kan vi endnu ikke bruge den i RStudio. Den skal først indlæses. Dette kan gøres med funktionen library().

```{r eval = F}
library(devtools)
```

Bemærk at her skal der ikke anførselstegn rundt om pakkenavnet. Dette er en almindelig kilde til fejl.

Man kan vælge ikke at indlæse hele pakken, men bare bruge en specifik funktion fra en specifik pakke. Dette gøres ved at brug af denne notation `devtools::install_github()`. Som består af pakkenavn og funktionsnavn.

Med den første metode sparer man en del tasteri.

ØVELSE: installer devtools. (skal vi ikke hellere vente til det med bi-plot)

## Funktioner med samme navn
Eftersom der ikke er noget der forhindrer os, eller andre i at lave nye funktioner der hedder det samme som en eksisterende funktion, kan der opstå "konflikter". Når vi indlæser en pakke med library funktionen ser vi ofte en besked om en konflikt, Eksempelvis: `x dplyr::filter() masks stats::filter()`

Det betyder blot at Rs indbyggede pakke `stats` har en funktion der hedder `filter()`. Det har pakken `dplyr` også. Og eftersom `dplyr` er indlæst efter R er startet op, så vil R bruge den sidst indlæste udgave af filter.


Hvis vi har brug for en specifik udgave af en funktion, der kommer fra en bestemt pakke, kan vi kalde den,
eksempelvis: `stats::filter()`

Som tidligere omtalt, vil vi godt have et samlet script, som kan køre fra start til slut. Og derfor er det god praksis at placere alle `library()` funktionerne i starten af scriptet. Ovenover disse kan man med fordel placere `install.packages()`
funktionerne (Husk dog at udkommentere disse, da vi ikke ønsker at køre dem hver gang scriptet bliver kørt)

Enkelte pakker er ikke tilgængelige på `CRAN`. Det hyppigste sted vi installerer pakker fra, der ikke findes på CRAN, er Github.

## ggbiplot
Vi kommer ikke her til at bruge tid på biplots. Det er en del af
kurset fødevaredataanalyse, og Morten forklarer bedre end vi 
nogensinde kommer til hvad PCA er og hvad det kan bruges til.

En pakke I kommer til at bruge til at plotte resultaterne af 
en Principal Component Analyse, er `ggbiplot`.

Den ligger ikke på CRAN, men på GitHub, og skal derfor installeres
på en særlig måde: 

```{r ggbiplot-fra-github, eval = F}
#install.packages("devtools")
#library(devtools)
install_github("vqv/ggbiplot")
```

Pakken devtools indeholder en funktion; `install_github()`. Den skal
have navnet på det "repository" på GitHub der indeholder pakken.

> ## Undervisningsmaterialet giver en fejl!
> I undervisningsmaterialet angives en anden måde at 
> installere pakken på:
>
>install_github("ggbiplot", "vqv")
>
> Det udløser en kedelig fejlbesked:
>
> Error in parse_repo_spec(repo) : 
> 
> Invalid git repo specification: 'ggbiplot'
> 
> Hvorfor? Fordi install_github funktionen er blevet opdateret, og 
> nu skal have adressen specificeret på en anden måde.
{: .callout}

For de fleste brugere af github er det en gratis tjeneste. Det 
fører til begrænsninger. En af dem er hvor mange der kan 
downloade pakker indenfor et bestemt tidsrum. Og den begrænsning
støder nogle af jer på i dette kursus.

Og hvad gør man så når man skal bruge ggbiplot, men ikke kan få
lov at installere pakken?

Lige ggbiplot er en *meget* simpel pakke. Den indeholder en enkelt
funktion. Og den kan vi få adgang til på andre måder.

I jeres projekt laver I mappen `scripts`. I den mappe opretter
I en R-script fil med navnet `ggbiplot.R`. Den åbner I, og kopierer
nedenstående R-kode ind i den:

KAN dette gøres på en smartere måde, så det ikke fylder så meget på skærmen
```{r ggbiplot-kode, eval = F}
ggbiplot <- function(pcobj, choices = 1:2, scale = 1, pc.biplot = TRUE, 
                      obs.scale = 1 - scale, var.scale = scale, 
                      groups = NULL, ellipse = FALSE, ellipse.prob = 0.68, 
                      labels = NULL, labels.size = 3, alpha = 1, 
                      var.axes = TRUE, 
                      circle = FALSE, circle.prob = 0.69, 
                      varname.size = 3, varname.adjust = 1.5, 
                      varname.abbrev = FALSE, ...)
{
  library(ggplot2)
  library(plyr)
  library(scales)
  library(grid)

  stopifnot(length(choices) == 2)

  # Recover the SVD
 if(inherits(pcobj, 'prcomp')){
    nobs.factor <- sqrt(nrow(pcobj$x) - 1)
    d <- pcobj$sdev
    u <- sweep(pcobj$x, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- pcobj$rotation
  } else if(inherits(pcobj, 'princomp')) {
    nobs.factor <- sqrt(pcobj$n.obs)
    d <- pcobj$sdev
    u <- sweep(pcobj$scores, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- pcobj$loadings
  } else if(inherits(pcobj, 'PCA')) {
    nobs.factor <- sqrt(nrow(pcobj$call$X))
    d <- unlist(sqrt(pcobj$eig)[1])
    u <- sweep(pcobj$ind$coord, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- sweep(pcobj$var$coord,2,sqrt(pcobj$eig[1:ncol(pcobj$var$coord),1]),FUN="/")
  } else if(inherits(pcobj, "lda")) {
      nobs.factor <- sqrt(pcobj$N)
      d <- pcobj$svd
      u <- predict(pcobj)$x/nobs.factor
      v <- pcobj$scaling
      d.total <- sum(d^2)
  } else {
    stop('Expected a object of class prcomp, princomp, PCA, or lda')
  }

  # Scores
  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[,choices], 2, d[choices]^obs.scale, FUN='*'))

  # Directions
  v <- sweep(v, 2, d^var.scale, FUN='*')
  df.v <- as.data.frame(v[, choices])

  names(df.u) <- c('xvar', 'yvar')
  names(df.v) <- names(df.u)

  if(pc.biplot) {
    df.u <- df.u * nobs.factor
  }

  # Scale the radius of the correlation circle so that it corresponds to 
  # a data ellipse for the standardized PC scores
  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)

  # Scale directions
  v.scale <- rowSums(v^2)
  df.v <- r * df.v / sqrt(max(v.scale))

  # Change the labels for the axes
  if(obs.scale == 0) {
    u.axis.labs <- paste('standardized PC', choices, sep='')
  } else {
    u.axis.labs <- paste('PC', choices, sep='')
  }

  # Append the proportion of explained variance to the axis labels
  u.axis.labs <- paste(u.axis.labs, 
                       sprintf('(%0.1f%% explained var.)', 
                               100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))

  # Score Labels
  if(!is.null(labels)) {
    df.u$labels <- labels
  }

  # Grouping variable
  if(!is.null(groups)) {
    df.u$groups <- groups
  }

  # Variable Names
  if(varname.abbrev) {
    df.v$varname <- abbreviate(rownames(v))
  } else {
    df.v$varname <- rownames(v)
  }

  # Variables for text label placement
  df.v$angle <- with(df.v, (180/pi) * atan(yvar / xvar))
  df.v$hjust = with(df.v, (1 - varname.adjust * sign(xvar)) / 2)

  # Base plot
  g <- ggplot(data = df.u, aes(x = xvar, y = yvar)) + 
          xlab(u.axis.labs[1]) + ylab(u.axis.labs[2]) + coord_equal()

  if(var.axes) {
    # Draw circle
    if(circle) 
    {
      theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
      circle <- data.frame(xvar = r * cos(theta), yvar = r * sin(theta))
      g <- g + geom_path(data = circle, color = muted('white'), 
                         size = 1/2, alpha = 1/3)
    }

    # Draw directions
    g <- g +
      geom_segment(data = df.v,
                   aes(x = 0, y = 0, xend = xvar, yend = yvar),
                   arrow = arrow(length = unit(1/2, 'picas')), 
                   color = muted('red'))
  }

  # Draw either labels or points
  if(!is.null(df.u$labels)) {
    if(!is.null(df.u$groups)) {
      g <- g + geom_text(aes(label = labels, color = groups), 
                         size = labels.size)
    } else {
      g <- g + geom_text(aes(label = labels), size = labels.size)      
    }
  } else {
    if(!is.null(df.u$groups)) {
      g <- g + geom_point(aes(color = groups), alpha = alpha)
    } else {
      g <- g + geom_point(alpha = alpha)      
    }
  }

  # Overlay a concentration ellipse if there are groups
  if(!is.null(df.u$groups) && ellipse) {
    theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
    circle <- cbind(cos(theta), sin(theta))

    ell <- ddply(df.u, 'groups', function(x) {
      if(nrow(x) <= 2) {
        return(NULL)
      }
      sigma <- var(cbind(x$xvar, x$yvar))
      mu <- c(mean(x$xvar), mean(x$yvar))
      ed <- sqrt(qchisq(ellipse.prob, df = 2))
      data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = '+'), 
                 groups = x$groups[1])
    })
    names(ell)[1:2] <- c('xvar', 'yvar')
    g <- g + geom_path(data = ell, aes(color = groups, group = groups))
  }

  # Label the variable axes
  if(var.axes) {
    g <- g + 
    geom_text(data = df.v, 
              aes(label = varname, x = xvar, y = yvar, 
                  angle = angle, hjust = hjust), 
              color = 'darkred', size = varname.size)
  }
  # Change the name of the legend for groups
  # if(!is.null(groups)) {
  #   g <- g + scale_color_brewer(name = deparse(substitute(groups)), 
  #                               palette = 'Dark2')
  # }

  # TODO: Add a second set of axes

  return(g)
}
```

Gem derefter filen. Nu har I en ggbiplot.R fil liggende i
jeres projekt. Den kan indlæses på en snedig måde, der giver
jer adgang til funktionen også selvom I ikke har kunne installere den.

I starten af jeres script, lige efter I ellers har indlæst
biblioteker, sætter I en enkelt linie ind:
```{r source-ggbiplot.R, eval = F }
source("scripts/ggbiplot.R")
```

Og så er der fri adgang til at bruge ggbiplot funktionen fuldstændig
som om den var installeret. 

Husk alligevel at få installeret ggbiplot-pakken ved lejlighed.
Metoden herover fungerer fint, men får ikke hjælpe filer og
andet nyttigt med, så det ér en nødløsning.

# Holde R, RStudio og pakker opdateret.
Det er et stykke tid siden I brugte R sidst. Så nu er der sikkert kommet 
opdateringer.

Det er en god ide at bruge den samme version af R hele vejen gennem dette kursus.
Det er ikke meget avancerede ting I kommer til at lave, så problemet vil næppe
være stort. Men det vil være meget træls at opdatere R dagen før eksamen og finde
ud af at noget er holdt op med at virke.

Så.
Opdater RStudio og opdater R.

R opdaterer vi ganske enkelt ved at installere seneste version.

R studio er også blot at downloade og installere den. Så fungerer tingene.

Husk at når I har opdateret RStudio, og særligt når I har opdateret R, så
vil der sandsynligvis være en del af de pakker I allerede har installeret, der 
skal opdateres.

Vi har under alle omstændigheder behov for at have pakken devtools installeret.
Det betyder at vi kan kalde følgende funktion, der tillader os at vælge 
hvilke der skal opdateres.

```{r eval = F}
devtools::update_packages()
```


## noter:

* Pakker hører til i starten.
* Rækkefølgen er installer pakker, og dernæst indlæs pakker.
* masking og conflicts af funktioner. Så tænk også over rækkefølgen af
* library! og dermed pakkenavn::funktion
* installer devtools!
* Brug devtools til at opdatere (praktisk øvelse)
* github vs. cran vs. lokale funktioner/source
* installer ggbiplot
  det er en funktion 
    og kan derfor "indlæses" med source funktionen. (og den ligger fint i en scripts mappe!)




{% include links.md %}