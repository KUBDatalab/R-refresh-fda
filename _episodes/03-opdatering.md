---
# Please do not edit this file directly; it is auto generated.
# Instead, please edit 03-opdatering.md in _episodes_rmd/
title: "Pakker og opdatering"
teaching: 10
exercises: 5
questions:
- "FIX ME"
objectives:
- "FIX ME"
keypoints:
- "FIX ME"

source: Rmd
---





## Pakker

Pakker i R er samlinger af funktioner der i forskellige
sammenhænge er nyttige. 

Når vi skal bruge en pakke, skal vi gøre to ting.

Vi skal installere den på computeren. 

Og vi skal indlæse den i R.

De fleste pakker vi får brug for, er samlet på `CRAN`,
"The Comprehensive R Archive Network". 

De pakker der findes dér, er blevet udsat for et minimum
af kvalitetskontrol. Der er ingen garantier for at de
fungerer som vi forventer, men sandsynligheden er ret høj.

Pakker fra `CRAN` installeres på denne måde:


~~~
install.packages("devtools")
~~~
{: .language-r}

Vi angiver navnet på pakken som en tekststreng. install.packages() funktionen søger efter navnet, og 
finder den noget, installeres pakken på vores computer.

I dette tilfælde er det pakken `devtools` en samling
af værktøjer der er nyttige når man udvikler ny
funktionalitet i R. Men pakken indeholder andet der
kan være nyttigt i dette kursus.

ØVELSE: installer devtools.

Når vi har installeret pakken, har vi adgang til de 
funktioner der ligger i pakken. Vi kan bruge dem
på to måder:

1. vi kan indlæse alle funktioner ved hjælp af 
funktionen `library(devtools)`
2. vi kan kalde specifikke funktioner fra en specifik
pakke ved en særlig notation: `devtools::install_github()`

Med den første metode sparer man en del tasteri.

Eftersom der ikke er noget der forhindrer os, eller andre
i at lave nye funktioner der hedder det samme som en
eksisterende funktion, kan der opstå "konflikter". Når 
vi indlæser en pakke med library funktionen ser vi 
ofte en besked om en konflikt, Eksempelvis:
"x dplyr::filter() masks stats::filter()"

Det betyder blot at Rs indbyggede pakke `stats` har en
funktion der hedder `filter()`. Det har pakken `dplyr` også. Og eftersom `dplyr` er indlæst efter R er startet
op, så vil R bruge den sidst indlæste udgave af filter.

Hvis vi har brug for en specifik udgave af en funktion, der kommer fra en bestemt pakke, kan vi kalde den,
eksempelvis: `stats::filter()`

Som tidligere omtalt, vil vi godt have et samlet script, som vi kan køre fra start til slut. Og derfor
er det god praksis at placere alle `library()` funktionerne i starten af scriptet. Lige inden man gør det, kan man med fordel placere `install.packages()`
funktionerne:

~~~
# install.packages("devtools")
library(devtools)
~~~
{: .language-r}

Overvej også hvilken rækkefølge pakkerne indlæses i.
Nogen af dem kan maskere hinandens funktioner. 

LIDT MERE OM DET - PASSET BEDRE IND.  

Enkelte pakker er ikke tilgængelige på `CRAN`. Det 
hyppigste sted vi installerer pakker fra, der ikke findes 
på CRAN, er Github.

## ggbiplot

Vi kommer ikke her til at bruge tid på biplots. Det er en del af
kurset fødevaredataanalyse, og Morten forklarer bedre end vi 
nogensinde kommer til hvad PCA er og hvad det kan bruges til.

En pakke I kommer til at bruge til at plotte resultaterne af 
en Principal Component Analyse, er `ggbiplot`.

Den ligger ikke på CRAN, men på GitHub, og skal derfor installeres
på en særlig måde: 


~~~
library(devtools)
install_github("vqv/ggbiplot")
~~~
{: .language-r}

Pakken devtools indeholder en funktion; `install_github()`. Den skal
have navnet på det "repository" på GitHub der indeholder pakken.

MARKERING: I undervisningsmaterialet angives en anden måde at 
installere pakken på:
install_github("ggbiplot", "vqv")
Det udløser en kedelig fejlbesked:
Error in parse_repo_spec(repo) : 
Invalid git repo specification: 'ggbiplot'

Hvorfor? Fordi install_github funktionen er blevet opdateret, og 
nu skal have adressen specificeret på en anden måde.

For de fleste brugere af github er det en gratis tjeneste. Det 
fører til begrænsninger. En af dem er hvor mange der kan 
downloade pakker indenfor et bestemt tidsrum. Og den begrænsning
støder nogle af jer på i dette kursus.

Og hvad gør man så når man skal bruge ggbiplot, men ikke kan få
lov at installere pakken?

Lige ggbiplot er en *meget* simpel pakke. Den indeholder en enkelt
funktion. Og den kan vi få adgang til på andre måder.

I jeres projekt laver I mappen `scripts`. I den mappe opretter
I en R-script fil med navnet `ggbiplot.R`. Den åbner I, og kopierer
nedenstående R-kode ind i den:

~~~
ggbiplot <- function(pcobj, choices = 1:2, scale = 1, pc.biplot = TRUE, 
                      obs.scale = 1 - scale, var.scale = scale, 
                      groups = NULL, ellipse = FALSE, ellipse.prob = 0.68, 
                      labels = NULL, labels.size = 3, alpha = 1, 
                      var.axes = TRUE, 
                      circle = FALSE, circle.prob = 0.69, 
                      varname.size = 3, varname.adjust = 1.5, 
                      varname.abbrev = FALSE, ...)
{
  library(ggplot2)
  library(plyr)
  library(scales)
  library(grid)

  stopifnot(length(choices) == 2)

  # Recover the SVD
 if(inherits(pcobj, 'prcomp')){
    nobs.factor <- sqrt(nrow(pcobj$x) - 1)
    d <- pcobj$sdev
    u <- sweep(pcobj$x, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- pcobj$rotation
  } else if(inherits(pcobj, 'princomp')) {
    nobs.factor <- sqrt(pcobj$n.obs)
    d <- pcobj$sdev
    u <- sweep(pcobj$scores, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- pcobj$loadings
  } else if(inherits(pcobj, 'PCA')) {
    nobs.factor <- sqrt(nrow(pcobj$call$X))
    d <- unlist(sqrt(pcobj$eig)[1])
    u <- sweep(pcobj$ind$coord, 2, 1 / (d * nobs.factor), FUN = '*')
    v <- sweep(pcobj$var$coord,2,sqrt(pcobj$eig[1:ncol(pcobj$var$coord),1]),FUN="/")
  } else if(inherits(pcobj, "lda")) {
      nobs.factor <- sqrt(pcobj$N)
      d <- pcobj$svd
      u <- predict(pcobj)$x/nobs.factor
      v <- pcobj$scaling
      d.total <- sum(d^2)
  } else {
    stop('Expected a object of class prcomp, princomp, PCA, or lda')
  }

  # Scores
  choices <- pmin(choices, ncol(u))
  df.u <- as.data.frame(sweep(u[,choices], 2, d[choices]^obs.scale, FUN='*'))

  # Directions
  v <- sweep(v, 2, d^var.scale, FUN='*')
  df.v <- as.data.frame(v[, choices])

  names(df.u) <- c('xvar', 'yvar')
  names(df.v) <- names(df.u)

  if(pc.biplot) {
    df.u <- df.u * nobs.factor
  }

  # Scale the radius of the correlation circle so that it corresponds to 
  # a data ellipse for the standardized PC scores
  r <- sqrt(qchisq(circle.prob, df = 2)) * prod(colMeans(df.u^2))^(1/4)

  # Scale directions
  v.scale <- rowSums(v^2)
  df.v <- r * df.v / sqrt(max(v.scale))

  # Change the labels for the axes
  if(obs.scale == 0) {
    u.axis.labs <- paste('standardized PC', choices, sep='')
  } else {
    u.axis.labs <- paste('PC', choices, sep='')
  }

  # Append the proportion of explained variance to the axis labels
  u.axis.labs <- paste(u.axis.labs, 
                       sprintf('(%0.1f%% explained var.)', 
                               100 * pcobj$sdev[choices]^2/sum(pcobj$sdev^2)))

  # Score Labels
  if(!is.null(labels)) {
    df.u$labels <- labels
  }

  # Grouping variable
  if(!is.null(groups)) {
    df.u$groups <- groups
  }

  # Variable Names
  if(varname.abbrev) {
    df.v$varname <- abbreviate(rownames(v))
  } else {
    df.v$varname <- rownames(v)
  }

  # Variables for text label placement
  df.v$angle <- with(df.v, (180/pi) * atan(yvar / xvar))
  df.v$hjust = with(df.v, (1 - varname.adjust * sign(xvar)) / 2)

  # Base plot
  g <- ggplot(data = df.u, aes(x = xvar, y = yvar)) + 
          xlab(u.axis.labs[1]) + ylab(u.axis.labs[2]) + coord_equal()

  if(var.axes) {
    # Draw circle
    if(circle) 
    {
      theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
      circle <- data.frame(xvar = r * cos(theta), yvar = r * sin(theta))
      g <- g + geom_path(data = circle, color = muted('white'), 
                         size = 1/2, alpha = 1/3)
    }

    # Draw directions
    g <- g +
      geom_segment(data = df.v,
                   aes(x = 0, y = 0, xend = xvar, yend = yvar),
                   arrow = arrow(length = unit(1/2, 'picas')), 
                   color = muted('red'))
  }

  # Draw either labels or points
  if(!is.null(df.u$labels)) {
    if(!is.null(df.u$groups)) {
      g <- g + geom_text(aes(label = labels, color = groups), 
                         size = labels.size)
    } else {
      g <- g + geom_text(aes(label = labels), size = labels.size)      
    }
  } else {
    if(!is.null(df.u$groups)) {
      g <- g + geom_point(aes(color = groups), alpha = alpha)
    } else {
      g <- g + geom_point(alpha = alpha)      
    }
  }

  # Overlay a concentration ellipse if there are groups
  if(!is.null(df.u$groups) && ellipse) {
    theta <- c(seq(-pi, pi, length = 50), seq(pi, -pi, length = 50))
    circle <- cbind(cos(theta), sin(theta))

    ell <- ddply(df.u, 'groups', function(x) {
      if(nrow(x) <= 2) {
        return(NULL)
      }
      sigma <- var(cbind(x$xvar, x$yvar))
      mu <- c(mean(x$xvar), mean(x$yvar))
      ed <- sqrt(qchisq(ellipse.prob, df = 2))
      data.frame(sweep(circle %*% chol(sigma) * ed, 2, mu, FUN = '+'), 
                 groups = x$groups[1])
    })
    names(ell)[1:2] <- c('xvar', 'yvar')
    g <- g + geom_path(data = ell, aes(color = groups, group = groups))
  }

  # Label the variable axes
  if(var.axes) {
    g <- g + 
    geom_text(data = df.v, 
              aes(label = varname, x = xvar, y = yvar, 
                  angle = angle, hjust = hjust), 
              color = 'darkred', size = varname.size)
  }
  # Change the name of the legend for groups
  # if(!is.null(groups)) {
  #   g <- g + scale_color_brewer(name = deparse(substitute(groups)), 
  #                               palette = 'Dark2')
  # }

  # TODO: Add a second set of axes

  return(g)
}
~~~
{: .language-r}

Gem derefter filen. Nu har I en ggbiplot.R fil liggende i
jeres projekt. Den kan indlæses på en snedig måde, der giver
jer adgang til funktionen også selvom I ikke har kunne installere den.

I starten af jeres script, lige efter I ellers har indlæst
bibliotekek, sætter I en enkelt linie ind:

~~~
source("scripts/ggbiplot.R")
~~~
{: .language-r}

Og så er der fri adgang til at bruge ggbiplot funktionen fuldstændig
som om den var installeret. 

Husk alligevel at få installeret ggbiplot-pakken ved lejlighed.
Metoden herover fungerer fint, men får ikke hjælpe filer og
andet nyttigt med, så det ér en nødløsning.


## noter:

Pakker hører til i starten.
Rækkefølgen er installer pakker, og dernæst indlæs pakker.
masking og conflicts af funktioner. Så tænk også over rækkefølgen af
library! og dermed pakkenavn::funktion
installer devtools!
Brug devtools til at opdatere (praktisk øvelse)
github vs. cran vs. lokale funktioner/source
installer ggbiplot
  det er en funktion 
    og kan derfor "indlæses" med source funktionen. (og den ligger fint i en scripts mappe!)

Det er et stykke tid siden I brugte R sidst. Så nu er der sikkert kommet 
opdateringer.

Det er en god ide at bruge den samme version af R hele vejen gennem dette kursus.
Det er ikke meget avancerede ting I kommer til at lave, så problemet vil næppe
være stort. Men det vil være meget træls at opdatere R dagen før eksamen og finde
ud af at noget er holdt op med at virke.

Så.
Opdater RStudio.

og opdater R.

R opdaterer vi ganske enkelt ved at installere seneste version. Rstudio vælger
automatisk den seneste version af R.

R studio er også blot at downloade og installere den. Så fungerer tingene.

Husk at når I har opdateret RStudio, og særligt når I har opdateret R, så
vil der sandsynligvis være en del af de pakker I allerede har installeret, der 
skal opdateres.

Vi har under alle omstændigheder behov for at have pakken devtools installeret.
Det betyder at vi kan kalde følgende funktion, der tillader os at vælge 
hvilke der skal opdateres.


~~~
devtools::update_packages()
y <- rchisq(500, df = 3)
plot(qchisq(ppoints(500), df = 3))

ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
lm.D9 <- lm(weight ~ group)
summary(lm.D9)
~~~
{: .language-r}



{% include links.md %}
